Выбор инструкций в компиляторах
*******************************

В данном тексте мы уделим внимание финальной части компилятора, которая занимается выбором инструкций целевой архитекутры (англ. instruction selectopm), их переупорядочиванием (instruction scheduling) и распределению регистров (англ. register allocation). 



Instrucion selection


Раскрытие макросов (Macro Expansion)
====================================

Раскрытие маркосов исторически является первым и достаточно простым подходом к порождению инструкций. Зачастую реализация разделяется на две части: непосредственно макросы-шаблоны и процедура, которая применяет эти макросы к коду (macro expander). За счет этого разделения первая часть может быть специализирована под различные архитектуры, в то врeмя как вторая может быть написана один раз для всех архитектур.

.. TODO::

    Сказать при чем тут RISCV


template (macro) vs expand procedure (macro expander). Первое может быть специализировано для конкретной архитектуры, второй может быть один на всех.

Преимущества: просто и прямолинейно.

.. code-block:: none
    :caption: CAPTION_TEXT
    :emphasize-lines: 0

    expand ($3 <- $1 + $2) {
        r1 = getRegOf ($1);
        r2 = getRegOf ($2);
        r3 = mkNewReg ($3);
        print "add " + r3 + ", " + r1 + ", " + r2;
    }


.. TODO::

    Пример для RISCV

.. important::

        asdf

Наивное раскрытие макросов
--------------------------

Одной из первых работ по порождению кода с помощью маркосов является SIMCMP (SIMple CoMPiler) :cite:`Orgass1969ABF` . Другой пример -- GCL :cite:`Elson1970`


    //https://jterrace.github.io/sphinxtr/html/ch-figs/index.html#subfigures

.. subfigstart::

.. _fig-cc-teddy-base:

.. figure:: images/sel1.png
    :alt: Base Mesh + 128x128 Texture (334 KB)
    :width: 150
    :align: center
    
    Дерево выражений

.. _fig-cc-teddy-original:

.. code-block:: asm
    :caption: Пример кода на RISCV

    add t0, ra, rb
    mulw t0, t0, 2

.. subfigend::
    :width: 0.30
    :alt: Example Model Resolutions
    :label: fig-cc-teddy
    
    Пример простого выражения и его схема компиляции для RISC-V

.. .. comment::
..     Example of a teddy bear model at different resolutions of the
..     progressive format (1 draw call) and its original format (16 draw
..     calls). The size in KB assumes downloading progressively, |eg|
..     :num:`fig-cc-teddy-100`'s size includes lower-resolution textures.


Промежуточные предстваления вместо дереьев абстрактного синтаксиса
------------------------------------------------------------------

Первые компиляторы занимались порождением кода непосредственно на основе кода на языке программирования.
Это прямолинейный подход, который не может анализировать исходную программу в целом, а только по отдельным инструкциям.
К тому же оно привязывает порождение кода (т.е. компилятор) к конкретному языку программирования.

Более удачным вариантом является порождение кода из деревьев абстрактного синтаксиса. В наши дни код порождается из специального представления программ, которое получается после совершения различных оптимизаций. Примерами таких представлений могут быть ANF, SSA и C--.

.. TODO::

    Что-то написать


Порождение макросов из описания целевой машины
----------------------------------------------

Реалистичные компиляторы с какого-то момента времени должны начать поддерживать несколько целевых машин.
Проблемы с рукописными макросами начинаются, если машины начинают существенно различаться между собой.
Например, бывают разные классы регистров (ссылка), в которые можно класть только данные определенного вида, 
или некоторые архитектуры могут не иметь подходящих команд, и для выполнения операции над данными из DRAM необходимо задействовать дополнительный регистр.

.. table:: Доступ к 0му элементу массива в памяти для RISCV64 и AMD64

 +-----------------------------------------------------+
 | .. code-block:: c                                   |
 |    :caption: Код на Си                              |
 |                                                     |
 |    x = *a;                                          |
 |                                                     |
 +-----------------------------------------------------+
 | .. code-block:: asm                                 |
 |    :caption: AMD64                                  |
 |                                                     |
 |    ; AMD64                                          |
 |    mov rax, (sp)                                    |
 |                                                     |
 |    ; RISCV64                                        |
 |    ldw t0, (sp)                                     |
 |    mv a0, t0                                        |
 +-----------------------------------------------------+

В примере выше мы обращаемся к элементу в начале массива, массив находится на вершине стека. В архитекутре AMD64 мы можем сделать это непосредственно, в RISCV64 необходимо пользоваться промежуточным регистром. При генерации кода с помощью макросов приходится одновременно заниматься распределением регистров, что усложняется задачу порождения оптимального кода.


Писать макросы руками сложно, хотелось бы иметь генератор, который по описанию машины порождает соответствующие макросы.
Одна из первых попыток :cite:`Miller1971` сделать это была система Dmacs. 
Она предлагала два проприетарных языка: первый (Machine-Independent Macro Language (MIML)) 
определят 2-адресные команды, которые являлись представлением программы, а второй (Object Machine Macro Language (OMML)) декларативный язык использовался, чтобы преобразовывать MIML команды в ассемблерный код. 

.. code-block:: none
    :caption: 
        Представление арифметического выражения  A[I] = B + C[J] * D с помощью команд MIML. 
        Команда SS используется, чтобы переслать данные между разными источниками. 
        На аргументы ссылаются либо по имени, либо по номеру строки, где он использовался.
    :emphasize-lines: 0

    1: SS C,J
    2: IMUL 1,D
    3: IADD 2,B
    4: SS A,I
    5: ASSG 4,3
    
.. code-block:: none
    :caption: 
        Часть описания компьютера IBM-360 на языке OMML :cite:`Miller1971`. 
        Команда `rclass` описывает виды регистров, а `rpath` ---  разрешенные способы пересылки между видами регистров и памятью.

    rclass REG:  r2, r3, r4, r5, r6
    rclass FREG: fr0, fr2, fr4, fr6
    ...
    rpath WORD -> REG:    L  REG,WORD
    rpath REG  -> WORD:  ST  REG,WORD
    rpath FREG -> WORD:  LE FREG,WORD
    rpath WORD -> FREG: STE FREG,WORD
    ...
    ISUB s1 ,s2
    from REG(s1),REG(s2) emit SR s1 ,s2
    from REG(s1),WORD(s2) emit S s1 ,s2
    resultresultREG(s1)
    REG(s2)
    FMUL m1 ,m2 ( commutative )
    from FREG(m1),FREG(m2) emit MER m1 ,m2
    from FREG(m1),WORD(m2) emit ME m1 ,m2
    resultresultFREG(m1)
    FREG(m1)


.. todo:: 

    Дать определеня много-адресным кодам.

.. Раздел про further improvements  из дисера надо бы выкинуть


Покрытие деревьев
=================


.. subfigstart::

.. _fig-tree-covering-0:

.. code-block:: c
    :caption: Пример кода на RISCV

    x = A[i + 1];

.. _fig-tree-covering-1:

.. code-block:: text
    :caption: Пример кода на RISCV

    mv r <- var
    add r <- s + t
    mul r <- s × t
    muladd r <- s × t + u
    load r <- ∗s
    maload r <- ∗(s × t + u)

.. _fig-tree-covering-2:

.. figure:: images/sel2covering.png
    :alt: Base Mesh + 128x128 Texture (334 KB)
    :width: 200
    :align: center
    
    Дерево выражений


.. subfigend::
    :width: 0.30
    :alt: Example Model Resolutions
    :label: fig-cc-teddy
    
    Пример простого выражения и его схема компиляции для RISC-V



Ограничения покрытия деревьев.

Основным недостатком работы с деревьями выражений является то, что одинаковые подвыражения должны быть разделены по рёбрам и продублированы при построении дерева.
Такие преобразования известны в литературе как edge splitting и node duplication.
В зависимости от набора инструкций, не разделяя подвыражения можно добивать лучшего качества кода.

В примере ниже общее выражение для вычисления значения t было разделено, что приводит к покрытию m1,...m7,m9 со стоимостью 0+...+0+2+3+5=10.
Если представить дерево как граф без циклов, то его можно покрывать шаблонами m8 и m10, что даст стоимость 0+...+0+4+5=9.



.. subfigstart::

.. _fig-dag-covering-0:

.. code-block:: c
    :caption: Пример кода на Си

    t = a + b;
    x = c * t;
    y = *(( int *) t);

.. _fig-dag-covering-1:

.. table:: Инструкции. Нотация `*s` означает получения данных по адресу в памяти.

    +--------------------------------+------------+
    + Инструкция                     + Стоимость  +
    +--------------------------------+------------+
    + add r <- s + t                 + 2          +
    +--------------------------------+------------+
    + mul r <- s × t                 + 3          +
    +--------------------------------+------------+
    + addmul r <- (s + t) × u        + 4          +
    +--------------------------------+------------+
    + load r <- * s                  + 5          +
    +--------------------------------+------------+
    + addload r <- * (s + t)         + 5          +
    +--------------------------------+------------+

.. _fig-dag-covering-3:

.. figure:: images/sel2dag0.png
    :width: 400
    :align: center
    
    Expression trees after edge splitting.

.. _fig-dag-covering-4:

.. figure:: images/sel2dag1.png
    :alt: Base Mesh + 128x128 Texture (334 KB)
    :width: 300
    :align: center
    
    Дерево выражений


.. subfigend::
    :width: 0.30
    :alt: Example Model Resolutions
    :label: fig-tree-covering-bad
    
    Пример простого выражения и его схема компиляции для RISC-V



Покрытие DAG
============

Прочее
======

Instruction scheduling

Курс `cornell_cs4120`_ говорит, что оно не нужно, потому что процессор сам.

Difference between 3 address code and ANF


.. _специальности: https://se.math.spbu.ru/bachelor/software-engineering.html
.. _курсом Д. Булычева: https://compscicenter.ru/courses/compilers/2021-spring
.. _сдают в репозитории на GitHub: https://github.com/Kakadu/comp23hw
.. _материалы: https://disk.yandex.ru/d/k9p_q6Y3jEm-Rg
.. _cornell_cs4120: https://www.cs.cornell.edu/courses/cs4120/2023sp/notes.html

.. bibliography::
   :all: