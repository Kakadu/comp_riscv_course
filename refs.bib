@book{Blindell2016,
  author    = {Blindell, G.H.},
  year      = {2016},
  month     = {01},
  pages     = {1-177},
  title     = {Instruction selection: Principles, methods, and applications},
  journal   = {Instruction Selection: Principles, Methods, and Applications},
  publisher = {},
  doi       = {10.1007/978-3-319-34019-7}
}

@phdthesis{Blindell2018,
  author    = {Gabriel Hjort Blindell},
  title     = {Universal Instruction Selection},
  school    = {{KTH} Royal Institute of Technology, Sweden},
  year      = {2018},
  url       = {https://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-223599},
  urn       = {urn:nbn:se:kth:diva-223599},
  timestamp = {Fri, 18 Nov 2022 20:51:28 +0100},
  biburl    = {https://dblp.org/rec/phd/se/Blindell18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Koes2008,
  author    = {Koes, David Ryan and Goldstein, Seth Copen},
  title     = {Near-optimal instruction selection on dags},
  year      = {2008},
  isbn      = {9781595939784},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1356058.1356065},
  doi       = {10.1145/1356058.1356065},
  abstract  = {Instruction selection is a key component of code generation. High quality instruction selection is of particular importance in the embedded space where complex instruction sets are common and code size is a prime concern. Although instruction selection on tree expressions is a well understood and easily solved problem, instruction selection on directed acyclic graphs is NP-complete. In this paper we present NOLTIS, a near-optimal, linear time instruction selection algorithm for DAG expressions. NOLTIS is easy to implement, fast, and effective with a demonstrated average code size improvement of 5.1\% compared to the traditional tree decomposition and tiling approach.},
  booktitle = {Proceedings of the 6th Annual IEEE/ACM International Symposium on Code Generation and Optimization},
  pages     = {45–54},
  numpages  = {10},
  keywords  = {instruction selection},
  location  = {Boston, MA, USA},
  series    = {CGO '08}
}

@phdthesis{wilcox1971,
  author    = {Wilcox, Thomas Richard},
  title     = {Generating machine code for high-level programming languages},
  year      = {1971},
  publisher = {Cornell University},
  address   = {USA},
  school    = {}
}
;
@misc{Souper2018,
  title         = {Souper: A Synthesizing Superoptimizer},
  author        = {Sasnauskas, Raimondas and Chen, Yang  and Collingbourne, Peter  and Ketema, Jeroen  and Lup, Gratian  and Taneja, Jubi  and Regehr, John },
  year          = {2018},
  eprint        = {1711.04422},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL}
}


@inproceedings{Massalin1987,
  author    = {Massalin, Henry},
  title     = {Superoptimizer: a look at the smallest program},
  year      = {1987},
  isbn      = {0818608056},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/36206.36194},
  doi       = {10.1145/36206.36194},
  abstract  = {Given an instruction set, the superoptimizer finds the shortest program to compute a function. Startling programs have been generated, many of them engaging in convoluted bit-fiddling bearing little resemblance to the source programs which defined the functions. The key idea in the superoptimizer is a probabilistic test that makes exhaustive searches practical for programs of useful size. The search space is defined by the processor's instruction set, which may include the whole set, but it is typically restricted to a subset. By constraining the instructions and observing the effect on the output program, one can gain insight into the design of instruction sets. In addition, superoptimized programs may be used by peephole optimizers to improve the quality of generated code, or by assembly language programmers to improve manually written code.},
  booktitle = {Proceedings of the Second International Conference on Architectual Support for Programming Languages and Operating Systems},
  pages     = {122–126},
  numpages  = {5},
  location  = {Palo Alto, California, USA},
  series    = {ASPLOS II}
}


@article{Orgass1969ABF,
  title   = {A base for a mobile programming system},
  author  = {Richard J. Orgass and William M. Waite},
  journal = {Commun. ACM},
  year    = {1969},
  volume  = {12},
  pages   = {507-510},
  url     = {https://api.semanticscholar.org/CorpusID:8164996}
}

@article{Elson1970,
  author   = {Elson, M. and Rake, S. T.},
  journal  = {IBM Systems Journal},
  title    = {Code-generation technique for large-language compilers},
  year     = {1970},
  volume   = {9},
  number   = {3},
  pages    = {166-188},
  keywords = {},
  doi      = {10.1147/sj.93.0166}
}

@techreport{Miller1971,
  author      = {Miller, P. L.},
  title       = {AUTOMATIC CREATION OF A CODE GENERATOR FROM A MACHINE DESCRIPTION},
  year        = {1971},
  publisher   = {Massachusetts Institute of Technology},
  address     = {USA},
  institution = {},
  abstract    = {This paper studies some of the problems involved in attaining machine independence for a code generator, similar to the language independence and the token independence attained by automatic parsing and automatic lexical systems. In particular, the paper examines the logic involved in two areas of code generation: computation and data reference. It presents models embodying the logic of each area and demonstrates how the models can be filled out by descriptive information about a particular machine. The paper also describes how the models can be incorporated into a descriptive macro code generating system (DMACS) to be used as a tool by a language implementor in creating a machine independent code generator, which can be made machine-directed by a suitable description of a particular machine.}
}

@article{Aho1989,
  author     = {Aho, Alfred V. and Ganapathi, Mahadevan and Tjiang, Steven W. K.},
  title      = {Code generation using tree matching and dynamic programming},
  year       = {1989},
  issue_date = {Oct. 1989},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {11},
  number     = {4},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/69558.75700},
  doi        = {10.1145/69558.75700},
  abstract   = {Compiler-component generators, such as lexical analyzer generators and parser generators, have long been used to facilitate the construction of compilers. A tree-manipulation language called twig has been developed to help construct efficient code generators. Twig transforms a tree-translation scheme into a code generator that combines a fast top-down tree-pattern matching algorithm with dynamic programming. Twig has been used to specify and construct code generators for several experimental compilers targeted for different machines.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {oct},
  pages      = {491–516},
  numpages   = {26}
}

@article{10.1145/872726.806978,
  author     = {Graham, Susan L. and Henry, Robert R. and Schulman, Robert A.},
  title      = {An experiment in table driven code generation},
  year       = {1982},
  issue_date = {June 1982},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {17},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/872726.806978},
  doi        = {10.1145/872726.806978},
  abstract   = {We have constructed a local code generator for the VAX-112 using a parser-like instruction pattern matcher. The code generator replaces the second pass of the UNIX3 Portable “Crdquo; compiler. This paper describes the design of the code generator and the special considerations imposed by the pattern matching process. We summarize the structure of the machine description grammar and its associated semantic actions, as well as the tools we developed to manipulate the large VAX description. In our experience, this approach makes the instruction selection phase of the compiler easier and faster to implement, and more likely to be correct than traditional techniques.},
  journal    = {SIGPLAN Not.},
  month      = {jun},
  pages      = {32–43},
  numpages   = {12}
}

@inproceedings{VAX1982,
  author    = {Graham, Susan L. and Henry, Robert R. and Schulman, Robert A.},
  title     = {An experiment in table driven code generation},
  year      = {1982},
  isbn      = {0897910745},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/800230.806978},
  doi       = {10.1145/800230.806978},
  abstract  = {We have constructed a local code generator for the VAX-112 using a parser-like instruction pattern matcher. The code generator replaces the second pass of the UNIX3 Portable “Crdquo; compiler. This paper describes the design of the code generator and the special considerations imposed by the pattern matching process. We summarize the structure of the machine description grammar and its associated semantic actions, as well as the tools we developed to manipulate the large VAX description. In our experience, this approach makes the instruction selection phase of the compiler easier and faster to implement, and more likely to be correct than traditional techniques.},
  booktitle = {Proceedings of the 1982 SIGPLAN Symposium on Compiler Construction},
  pages     = {32–43},
  numpages  = {12},
  location  = {Boston, Massachusetts, USA},
  series    = {SIGPLAN '82}
}


@inproceedings{GlanvilleGraham1978,
  author    = {Glanville, R. Steven and Graham, Susan L.},
  title     = {A new method for compiler code generation},
  year      = {1978},
  isbn      = {9781450373487},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/512760.512785},
  doi       = {10.1145/512760.512785},
  abstract  = {An algorithm is given to translate a relatively low-level intermediate representation of a program into assembly code or machine code for a target computer. The algorithm is table driven. A construction algorithm is used to produce the table from a functional description of the target machine. The method produces high quality code for many commercially available computers. By replacing the table, it is possible to retarget a compiler for another kind of computer. In addition techniques are given to prove the correctness of the translator.},
  booktitle = {Proceedings of the 5th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  pages     = {231–254},
  numpages  = {24},
  location  = {Tucson, Arizona},
  series    = {POPL '78}
}

@phdthesis{Newcomer1975,
  author    = {Newcomer, Joseph Michael},
  title     = {Machine-independent generation of optimal local code.},
  year      = {1975},
  publisher = {Carnegie Mellon University},
  address   = {USA},
  school    = {},
  note      = {AAI7521781}
}

@inproceedings{Nymeyer1996,
  author    = {Nymeyer, Albert and Katoen, Joost-Pieter and Westra, Ymte and Alblas, Henk},
  year      = {1995},
  month     = {12},
  pages     = {},
  booktitle = {},
  title     = {Code generation = A* + BURS},
  isbn      = {978-3-540-61053-3},
  doi       = {10.1007/3-540-61053-7_60}
}

@article{AhoCorasik1975,
  author     = {Aho, Alfred V. and Corasick, Margaret J.},
  title      = {Efficient string matching: an aid to bibliographic search},
  year       = {1975},
  issue_date = {June 1975},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {18},
  number     = {6},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/360825.360855},
  doi        = {10.1145/360825.360855},
  abstract   = {This paper describes a simple, efficient algorithm to locate all occurrences of any of a finite number of keywords in a string of text. The algorithm consists of constructing a finite state pattern matching machine from the keywords and then using the pattern matching machine to process the text string in a single pass. Construction of the pattern matching machine takes time proportional to the sum of the lengths of the keywords. The number of state transitions made by the pattern matching machine in processing the text string is independent of the number of keywords. The algorithm has been used to improve the speed of a library bibliographic search program by a factor of 5 to 10.},
  journal    = {Commun. ACM},
  month      = {jun},
  pages      = {333–340},
  numpages   = {8},
  keywords   = {text-editing, string pattern matching, keywords and phrases, information retrieval, finite state machines, computational complexity, bibliographic search}
}


@article{Ripken1977,
  author     = {Ripken, K. },
  title      = {Formale Beschreibung von Maschinen, Implementierungen
                und Optimierender Maschinencodeerzeugung aus Attributierten Program-
                mgraphen.},
  year       = {1977},
  issue_date = {July 1977},
  publisher  = {Munich, Germany: Institut für Informatik, Technical University of Munich,},
  address    = {New York, NY, USA},
  journal    = {Tech. rep. TUM-INFO-7731}
}

@online{Stallman1988,
  author = {Stallman, R.},
  title  = {Internals of GNU CC},
  year   = {1988},
  month  = {apr},
  url    = {https://web.archive.org/web/20120112142027/http://trinity.engr.uconn.edu/~vamsik/internals.pdf},
  doi    = {10.1145/69558.75700}
}

@article{Davidson1984,
  author     = {Davidson, Jack W. and Fraser, Christopher W.},
  title      = {Code selection through object code optimization},
  year       = {1984},
  issue_date = {Oct. 1984},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {6},
  number     = {4},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/1780.1783},
  doi        = {10.1145/1780.1783},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {oct},
  pages      = {505–526},
  numpages   = {22}
}

@online{Bendersky2013,
  author  = {Bendersky, E.},
  title   = { A Deeper Look into the LLVM Code Generator: Part 1.},
  url     = {http://eli.thegreenplace.net/2013/02/25/a-deeper-look-into-the-llvm-code-generator-part-1/},
  visited = {2024-02-10}
}

@phdthesis{Beg2013,
  author    = {Mirza Omer Beg},
  title     = {Combinatorial Problems in Compiler Optimization},
  school    = {University of Waterloo, Ontario, Canada},
  year      = {2013},
  url       = {https://hdl.handle.net/10012/7423},
  timestamp = {Wed, 04 May 2022 13:00:41 +0200},
  biburl    = {https://dblp.org/rec/phd/basesearch/Beg13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@phdthesis{Ullmann1976,
  author     = {Ullmann, J. R.},
  title      = {An Algorithm for Subgraph Isomorphism},
  year       = {1976},
  issue_date = {Jan. 1976},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {23},
  number     = {1},
  issn       = {0004-5411},
  url        = {https://doi.org/10.1145/321921.321925},
  doi        = {10.1145/321921.321925},
  abstract   = {Subgraph isomorphism can be determined by means of a brute-force tree-search enumeration procedure. In this paper a new algorithm is introduced that attains efficiency by inferentially eliminating successor nodes in the tree search. To assess the time actually taken by the new algorithm, subgraph isomorphism, clique detection, graph isomorphism, and directed graph isomorphism experiments have been carried out with random and with various nonrandom graphs.A parallel asynchronous logic-in-memory implementation of a vital part of the algorithm is also described, although this hardware has not actually been built. The hardware implementation would allow very rapid determination of isomorphism.},
  journal    = {J. ACM},
  month      = {jan},
  pages      = {31–42},
  numpages   = {12},
  school     = {}
}

@inproceedings{Cordella2001,
  title     = {An Improved Algorithm for Matching Large Graphs},
  author    = {Luigi P. Cordella and Pasquale Foggia and Carlo Sansone and Mario Vento},
  year      = {2001},
  url       = {https://api.semanticscholar.org/CorpusID:15968654},
  school    = {},
  booktitle = {}
}

@article{Cytron1991,
  author     = {Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K. and Wegman, Mark N. and Zadeck, F. Kenneth},
  title      = {Efficiently computing static single assignment form and the control dependence graph},
  year       = {1991},
  issue_date = {Oct. 1991},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {13},
  number     = {4},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/115372.115320},
  doi        = {10.1145/115372.115320},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {oct},
  pages      = {451–490},
  numpages   = {40},
  keywords   = {control dependence, control flow graph, def-use chain, dominator, optimizing compilers}
}

@article{Gerlek1995,
  author     = {Gerlek, Michael P. and Stoltz, Eric and Wolfe, Michael},
  title      = {Beyond induction variables: detecting and classifying sequences using a demand-driven SSA form},
  year       = {1995},
  issue_date = {Jan. 1995},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {17},
  number     = {1},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/200994.201003},
  doi        = {10.1145/200994.201003},
  abstract   = {Linear induction variable detection is usually associated with the strength reduction optimization. For restructuring compilers, effective data dependence analysis requires that the compiler detect and accurately describe linear and nonlinear induction variables as well as more general sequences. In this article we present a practical technique for detecting a broader class of linear induction variables than is usually recognized, as well as several other sequence forms, including periodic, polynomial, geometric, monotonic, and wrap-around variables. Our method is based on Factored Use-Def (FUD) chains, a demand-driven representation of the popular Static Single Assignment (SSA) form. In this form, strongly connected components of the associated SSA graph correspond to sequences in the source program: we describe a simple yet efficient algorithm for detecting and classifying these sequences. We have implemented this algorithm in Nascent, our restructuring Fortran 90+ compiler, and we present some results showing the effectiveness of our approach.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {jan},
  pages      = {85–122},
  numpages   = {38},
  keywords   = {constant propagation, def-use chain, demand-driven, induction variable, static single assignment, strength reduction, wraparound variable}
}


@article{10.1145/202530.202534,
  author     = {Click, Cliff and Paleczny, Michael},
  title      = {A simple graph-based intermediate representation},
  year       = {1995},
  issue_date = {March 1993},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {30},
  number     = {3},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/202530.202534},
  doi        = {10.1145/202530.202534},
  abstract   = {We present a graph-based intermediate representation (IR) with simple semantics and a low-memory-cost C++ implementation. The IR uses a directed graph with labeled vertices and ordered inputs but unordered outputs. Vertices are labeled with opcodes, edges are unlabeled. We represent the CFG and basic blocks with the same vertex and edge structures. Each opcode is defined by a C++ class that encapsulates opcode-specific data and behavior. We use inheritance to abstract common opcode behavior, allowing new opcodes to be easily defined from old ones. The resulting IR is simple, fast and easy to use.},
  journal    = {SIGPLAN Not.},
  month      = {mar},
  pages      = {35–49},
  numpages   = {15}
}

@inproceedings{Click1995,
  author    = {Click, Cliff and Paleczny, Michael},
  title     = {A simple graph-based intermediate representation},
  year      = {1995},
  isbn      = {0897917545},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/202529.202534},
  doi       = {10.1145/202529.202534},
  abstract  = {We present a graph-based intermediate representation (IR) with simple semantics and a low-memory-cost C++ implementation. The IR uses a directed graph with labeled vertices and ordered inputs but unordered outputs. Vertices are labeled with opcodes, edges are unlabeled. We represent the CFG and basic blocks with the same vertex and edge structures. Each opcode is defined by a C++ class that encapsulates opcode-specific data and behavior. We use inheritance to abstract common opcode behavior, allowing new opcodes to be easily defined from old ones. The resulting IR is simple, fast and easy to use.},
  booktitle = {Papers from the 1995 ACM SIGPLAN Workshop on Intermediate Representations},
  pages     = {35–49},
  numpages  = {15},
  location  = {San Francisco, California, USA},
  series    = {IR '95}
}

@article{10.1145/358438.349320,
  author     = {Larsen, Samuel and Amarasinghe, Saman},
  title      = {Exploiting superword level parallelism with multimedia instruction sets},
  year       = {2000},
  issue_date = {May 2000},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {35},
  number     = {5},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/358438.349320},
  doi        = {10.1145/358438.349320},
  abstract   = {Increasing focus on multimedia applications has prompted the addition
                of multimedia extensions to most existing general purpose microprocessors.  This added functionality comes primarily with the addition of short SIMD instructions.  Unfortunately, access to these instructions is limited to in-line assembly and library calls. Generally, it has been assumed that vector compilers provide the most promising means of exploiting multimedia instructions. Although vectorization technology is well understood, it is inherently complex and fragile. In addition, it is incapable of locating SIMD-style parallelism within a basic block.In this paper we introduce the concept of Superword Level Parallelism (SLP) ,a novel way of viewing parallelism in multimedia and scientific applications. We believe SLPP is  fundamentally different from the loop level parallelism exploited by traditional vector processing, and therefore demands a new method of extracting it.  We have developed a simple and robust compiler for detecting SLPP that targets basic blocks rather than loop nests.  As with techniques designed to extract ILP, ours is able to exploit parallelism both across loop iterations and within basic blocks. The result is an algorithm that provides excellent performance in several application domains. In our experiments, dynamic instruction counts were reduced by 46\%. Speedups ranged from 1.24 to 6.70.},
  journal    = {SIGPLAN Not.},
  month      = {may},
  pages      = {145–156},
  numpages   = {12}
}

@inproceedings{Larsen2000,
  author    = {Larsen, Samuel and Amarasinghe, Saman},
  title     = {Exploiting superword level parallelism with multimedia instruction sets},
  year      = {2000},
  isbn      = {1581131992},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/349299.349320},
  doi       = {10.1145/349299.349320},
  abstract  = {Increasing focus on multimedia applications has prompted the addition
               of multimedia extensions to most existing general purpose microprocessors.  This added functionality comes primarily with the addition of short SIMD instructions.  Unfortunately, access to these instructions is limited to in-line assembly and library calls. Generally, it has been assumed that vector compilers provide the most promising means of exploiting multimedia instructions. Although vectorization technology is well understood, it is inherently complex and fragile. In addition, it is incapable of locating SIMD-style parallelism within a basic block.In this paper we introduce the concept of Superword Level Parallelism (SLP) ,a novel way of viewing parallelism in multimedia and scientific applications. We believe SLPP is  fundamentally different from the loop level parallelism exploited by traditional vector processing, and therefore demands a new method of extracting it.  We have developed a simple and robust compiler for detecting SLPP that targets basic blocks rather than loop nests.  As with techniques designed to extract ILP, ours is able to exploit parallelism both across loop iterations and within basic blocks. The result is an algorithm that provides excellent performance in several application domains. In our experiments, dynamic instruction counts were reduced by 46\%. Speedups ranged from 1.24 to 6.70.},
  booktitle = {Proceedings of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation},
  pages     = {145–156},
  numpages  = {12},
  location  = {Vancouver, British Columbia, Canada},
  series    = {PLDI '00}
}

@online{Leather2019,
  author   = {Leather, Hugh},
  title    = {Deep Learning for Compilers},
  year     = {2019},
  url      = {https://www.inf.ed.ac.uk/teaching/courses/copt/lecture-15.pdf},
  location = {University of Edinburgh, UK}
}